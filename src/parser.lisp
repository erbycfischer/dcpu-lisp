(defpackage :edu.cis.uab.dcpu-lisp.parser
	(:use 
		:common-lisp
		:edu.cis.uab.dcpu-lisp.lexer)
	(:export
		:parse
		:get-lexemes))

(in-package :edu.cis.uab.dcpu-lisp.parser)

(defparameter *look-ahead-one* 'nil)
(defparameter *look-ahead-two* 'nil)
(defparameter *look-ahead-lexeme-one* 'nil)
(defparameter *look-ahead-lexeme-two* 'nil)

(defun match (symbol-to-match)
	(cond ((equal *look-ahead-one* symbol-to-match)
				(setf *look-ahead-lexeme-one* *look-ahead-lexeme-two*)
				(setf *look-ahead-lexeme-two* (get-token))
				(setf *look-ahead-one* (car *look-ahead-lexeme-one*))
				(setf *look-ahead-two* (car *look-ahead-lexeme-two*)))
		  (t
				(syntax-error symbol-to-match))))

(defun syntax-error (expected)
	(format t "Syntax error found.~%Found: ~S.~%Expected: ~S.~%" (cdr *look-ahead-lexeme-one*) expected)
	(sb-ext:exit))

(defun program ()
	(if (not (equal *look-ahead-one* 'nil))
		(forms)))

(defun forms ()
	(form)
	(cond ((equal *look-ahead-one* 'LPAR)
				(forms))
		  ((not (equal *look-ahead-one* 'nil))
		  		(syntax-error "EOF"))))

(defun form ()
	(if (or (equal *look-ahead-two* 'DEFINE)
			(equal *look-ahead-two* 'DEFUN))
		(definition)
		(expression)))

(defun definitions ()
	(definition)
	(if (or (equal *look-ahead-two* 'DEFINE)
			(equal *look-ahead-two* 'DEFUN))
			(definitions)))

(defun definition ()
	(match 'LPAR)
	(cond ((equal *look-ahead-one* 'DEFUN)
			(match 'DEFUN)
			(match 'ID)
			(formals)
			(body))
		  ((equal *look-ahead-one* 'DEFINE)
		  	(match 'DEFINE)
		  	(match 'ID)
		  	(expression)))
	(match 'RPAR))

(defun variables ()
	(match 'ID)
	(if (equal *look-ahead-one* 'ID)
		(variables)))

(defun body ()
	(cond ((or (equal *look-ahead-two* 'DEFUN)
			   (equal *look-ahead-two* 'DEFINE))
			(definitions)
			(expressions))
		  (t
		  	(expressions))))

(defun expressions ()
	(expression)
	(if (member *look-ahead-one* '(ID BOOL NUM CHAR STR LPAR))
				(expressions)))

(defun expression ()
	(cond ((not (equal *look-ahead-one* 'LPAR))
				(cond ((member *look-ahead-one* '(BOOL NUM CHAR STR))
						(constant))
					  ((equal *look-ahead-one* 'ID)
						(match 'ID))))
	(t
		(match 'LPAR)
		(cond
			((equal *look-ahead-one* 'LAMBDA)
				(match 'LAMBDA)
				(formals)
				(body))
			((equal *look-ahead-one* 'IF)
				(match 'IF)
				(expression)
				(expression)
				(expression))
			((equal *look-ahead-one* 'WHEN)
				(match 'WHEN)
				(expression)
				(expression))
			((equal *look-ahead-one* 'SET)
				(match 'SET)
				(match 'ID)
				(expression))
			((equal *look-ahead-one* 'MALLOC)
				(match 'MALLOC)
				(expression)
				(expression))
			((equal *look-ahead-one* 'FREE)
				(match 'FREE)
				(expression))
			((equal *look-ahead-one* 'WHILE)
				(match 'WHILE)
				(expression)
				(expression))
			(t
				(expressions)))
		(match 'RPAR))))

(defun constant ()
	(if (member *look-ahead-one* '(BOOL NUM CHAR STR))
		(match *look-ahead-one*)
		(syntax-error 'CONSTANT)))

(defun formals ()
	(match 'LPAR)
	(if (equal *look-ahead-one* 'ID)
		(variables))
	(match 'RPAR))

(defun parse ()
	(setf *look-ahead-lexeme-one* (get-token))
	(setf *look-ahead-lexeme-two* (get-token))
	(setf *look-ahead-one* (car *look-ahead-lexeme-one*))
	(setf *look-ahead-two* (car *look-ahead-lexeme-two*))
	(program)
	(format t "No syntax errors.~%"))
